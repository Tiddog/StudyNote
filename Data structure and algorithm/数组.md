# 数组基础理论

## 数组的实现

---

### 1. （增）有序数组的平方

[LeetCode 977.有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)

> **题目描述：**
> 给你一个按**非递减顺序**排序的整数数组 nums，返回**每个数字的平方**组成的新数组，要求也按**非递减顺序**排序。

#### （1）解题思路

+ 使用条件
  + 数组必须有序
+ 实现方式
  + 初始化左右指针和一个存放结果的数组arr
  + 进入while循环，中止条件为左指针越过右指针
    + 判断左边的平方和右边的平方哪个大
      + 左边大则左边加入arr，左指针右移
      + 右边大则右边加入arr，右指针左移
      + 数组arr的索引index-1
  + 返回数组res

#### （2）源码

```java
public int[] sortedSquares(int[] nums) {
    int l = 0, r = nums.length-1,index = nums.length-1;
    int[] res = new int[nums.length];
    while(l<=r){
        if(nums[l] * nums[l] < nums[r] * nums[r]){
            res[index] = nums[r] *nums[r];
            r--;
        }else{
            res[index] = nums[l] *nums[l];
            l++;
        }
        index--;
    }
    return res;
}
```

---

### 2. （增）螺旋矩阵

---

### 3. （删）移除元素

[LeetCode 27.移除元素](https://leetcode-cn.com/problems/remove-element/)


> **题目描述**
> 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
> 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
> 
> **说明:**
> 为什么返回数值是整数，但输出的答案是数组呢?
> 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
> 你可以想象内部操作如下:
> 
> ``` java
> // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
> int len = removeElement(nums, val);
> 
> // 在函数里修改输入数组对于调用者是可见的。
> // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
> for (int i = 0; i < len; i++) {
>     print(nums[i]);
> }
> ```

#### （1）解题思路
+ 使用条件
  + 均可
+ 实现方式
  + 初始化左右指针
    + 左指针指向数组起始节点
    + 右指针指向数组结束节点
  + 进入while循环，当左指针越过右指针时，结束循环
    + 如果左指针的值与目标值target相等，则将右指针的数放入左指针的位置，右指针左移一位
    + 否则左指针右移一位
  + 返回数组长度

#### （2）源码

```java
public int removeElement(int[] nums, int val) {
    int i = 0,j = nums.length-1;
    while(i<=j){
        if(nums[i] == val){
            nums[i] = nums[j];
            j--;
        }else{
            i++;
        }
    }
    return i;
}
```

---

### 4. （查）二分查找

[LeetCode 704.二分查找](https://leetcode-cn.com/problems/binary-search/)


> **题目描述:**
> 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。



#### （1）解题思路
+ 使用条件
  + 数组必须有序
+ 实现方式
  + 获取边界条件
  + 使用while循环，当左边界与右边界重合时结束
    + 循环中不断计算中间的脚标位置
    + 然后与目标值做比较
  + 最后返回结果


#### （2）源码

```java
public int search(int[] nums, int target) {
    int l = 0, r = nums.length -1;
    while(l <= r){
        if(nums[(l+r)/2]>target){
            r = (l+r)/2-1;
        }else if(nums[(l+r)/2]<target){
            l = (l+r)/2+1;
        }else if(nums[(l+r)/2] == target){
            return (l+r)/2;
        }
    }
    return -1;
}
```


---

### 5. （查）长度最小的子数组

[LeetCode 209.长度最小子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

> **题目描述：**
> 给定一个含有**n**个正整数的数组和一个正整数**target**。
> 
> 找出该数组中满足其和**≥ target**的长度最小的**连续子数组** **_[numsl, numsl+1, ..., numsr-1, numsr]_**，并返回其长度。如果不存在符合条件的子数组，返回 0 。

#### （1）解题思路

+ 使用条件
  + 均可
+ 实现方式
  + 初始化快慢指针
  + 

#### （2）源码

